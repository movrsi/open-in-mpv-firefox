#!/usr/bin/env python3

# This file is part of open-in-mpv.
#
# Copyright 2020 Andrew Udvare
# Copyright 2023 movrsi
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
from functools import lru_cache
from os.path import dirname, exists, expanduser, expandvars, isdir, join as path_join
from typing import Any, BinaryIO, Callable, Dict, Final, Mapping, TextIO
import json
import logging
import os
import platform
import random
import socket
import struct
import subprocess as sp
import sys
import time

WINDOWS: bool = True

try:
    import win32pipe, win32file, pywintypes
except:
    WINDOWS = False
    pass

@lru_cache()
def get_log_path() -> str:
    if platform.mac_ver()[0]:
        return expanduser('~/Library/Logs')
    if platform.win32_ver()[0]:
        return expandvars(r"%LOCALDATA%\open-in-mpv")
    return expanduser('~/.local/share/open-in-mpv')


@lru_cache()
def get_socket_path() -> str:
    if platform.mac_ver()[0]:
        return expanduser('~/Library/Caches/open-in-mpv.sock')
    if platform.win32_ver()[0]:
        return expandvars(r"\\.\pipe\open-in-mpv")
    return expanduser('~/.cache/open-in-mpv.sock')


LOG: logging.Logger = logging.getLogger('open-in-mpv')
LOG_PATH: Final[str] = get_log_path()
MPV_SOCKET: Final[str] = get_socket_path()
UNIX: Final[int] = 2
VERSION: Final[str] = 'v0.1.7'

def makedirs(path: str) -> None:
    try:
        os.makedirs(path)
    except OSError:
        pass

def removesocket() -> None:
    try:
        os.remove(MPV_SOCKET)
    except OSError:
        pass

def environment(data_resp: Dict[str, Any]) -> Dict[str, Any]:
     env = os.environ.copy()
     if isdir('/opt/local/bin'):
        LOG.info('Detected MacPorts. Setting PATH.')
        data_resp['macports'] = True
        old_path = os.environ.get('PATH')
        env['PATH'] = '/opt/local/bin' if not old_path else ':'.join(
            ('/opt/local/bin', old_path))
        
     return env

def parse_arguments(buffer: BinaryIO) -> Dict[str, Any]:
    ret: Dict[str, Any] = {}
    req_len = struct.unpack('@i', buffer.read(4))[0]
    message = json.loads(buffer.read(req_len).decode())
    LOG.debug('Message contents (%d): %s', req_len, message)
    ret['init'] = 'init' in message
    ret['url'] = message.get('url', None)
    ret['debug'] = message.get('debug', False)
    ret['single'] = message.get('single', True)
    return ret

def write_response(response: Dict[str, Any]) -> None:
    resp = json.dumps(response).encode()
    size = struct.pack('@i', len(resp))
    stdout_buffer: BinaryIO = sys.stdout.buffer
    stdout_buffer.write(size)
    stdout_buffer.write(resp)

def generate_json(type: int, url: str) -> str:
    match type:
         case 1:
            response: Dict[str, Any] = {
                "command": ["loadfile", url],
                "request_id": random.randint(0x01, 0x7fffffff)
            }
            
            return json.dumps(response).encode(
                errors='strict') + b"\n"
         case 2:
            return json.dumps(dict(command=['loadfile', url])).encode(
                    errors='strict') + b'\n'

def mpv_executable() -> str:
    return 'mpv.exe' if WINDOWS else 'mpv'

def spawn(func: Callable[[], Any]) -> None:
    """See Stevens' "Advanced Programming in the UNIX Environment" for details
    (ISBN 0201563177)
    Credit: https://stackoverflow.com/a/6011298/374110
    Takes a callable which will be called in the fork.
    """
    try:
        pid = os.fork()
        if pid > 0:
            # parent process, return and keep running
            return
    except OSError as exc:
        LOG.exception('Fork #1 failed: %s (%s)', exc.errno, exc.strerror)
        sys.exit(1)
    os.setsid()
    # do second fork
    LOG.debug('Second fork')
    try:
        pid = os.fork()
        if pid > 0:
            # exit from second parent
            sys.exit(0)
    except OSError as exc:
        LOG.exception('Fork #2 failed: %s (%s)', exc.errno, exc.strerror)
        sys.exit(1)
    LOG.debug('Calling callback')
    func()
    LOG.debug('Callback returned')
    # Exit without calling cleanup handlers
    os._exit(os.EX_OK)  # pylint: disable=protected-access


def mpv_and_cleanup(url: str, new_env: Mapping[str, str],
                    log: TextIO) -> Callable[[], None]:
    def cb() -> None:
        sp.check_call((
            mpv_executable(),
            '--quiet',
            '--player-operation-mode=pseudo-gui',
            f'--input-ipc-server={MPV_SOCKET}',
            url,
        ),
                      env=new_env,
                      stderr=log,
                      stdout=log)
        os.remove(MPV_SOCKET)

    return cb


def spawn_init(url: str, log: TextIO, new_env: Mapping[str, str]) -> None:
    LOG.debug('Spawning initial instance')
    spawn(mpv_and_cleanup(url, new_env, log))


def get_unix_callback(url: str, log: TextIO,
                 new_env: Mapping[str, str]) -> Callable[[], None]:
    def callback() -> None:
         LOG.debug('Sending loadfile command')
         s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
         s.settimeout(2)
         
         try:
             s.connect(MPV_SOCKET)
             s.settimeout(None)
             LOG.debug('Connected to socket')
             s.send(generate_json(UNIX, url))
         except socket.error:
            LOG.exception('Connection refused')
            removesocket()
            spawn_init(url, log, new_env)

    return callback

def get_win32_callback(url: str, log: TextIO,
                 new_env: Mapping[str, str]) -> Callable[[], None]:
    def callback() -> None:
        try:
            handle = win32file.CreateFile(
                MPV_SOCKET, win32file.GENERIC_READ | win32file.GENERIC_WRITE,
                0, None, win32file.OPEN_EXISTING, 0, None)
            
            res = win32pipe.SetNamedPipeHandleState(handle, 
                win32pipe.PIPE_READMODE_MESSAGE, None, None)
            
            if res == 0:
                LOG.debug(f"SetNamedPipeHandleState return code: {res}")
                return
            
            win32file.WriteFile(handle, generate_json(WINDOWS, url))

            # Receive data from MPV (i don't believe this will be needed)
            # resp = win32file.ReadFile(handle, 64*1024)
            # LOG.debug(f"message: {resp}")
        except pywintypes.error as e:
            match e.args[0]:
                case 2:
                    LOG.debug("Pipe not found, retrying in a second")
                    time.sleep(1)
                    callback()
                case 109:
                    LOG.debug("Broken pipe")
                    spawn_init(url, log, new_env)

    return callback

def real_main(log: TextIO) -> int:
    makedirs(dirname(MPV_SOCKET))
    LOG.setLevel(logging.ERROR)
    LOG.addHandler(logging.StreamHandler(log))
    message: Dict[str, Any] = parse_arguments(sys.stdin.buffer)

    if message['init']:
        resp = json.dumps(
            dict(version=VERSION, logPath=log.name,
                 socketPath=MPV_SOCKET)).encode()
        size = struct.pack('@i', len(resp))
        stdout_buffer = sys.stdout.buffer
        stdout_buffer.write(size)
        stdout_buffer.write(resp)
        log.close()
        return 0
    
    if message['url'] is None:
        LOG.exception('No URL was given')
        print(json.dumps(dict(message='Missing URL!')))
        return 1
    
    if message['debug']:
        LOG.setLevel(logging.DEBUG)
        LOG.info('Debug mode enabled.')

    # MacPorts
    data_resp: Dict[str, Any] = dict(version=VERSION,
                                            log_path=log.name,
                                        message='About to spawn')
    data_resp['env'] = environment(data_resp)
    LOG.debug('About to spawn')
    write_response(data_resp)

    if WINDOWS and message['single']:
        spawn(get_win32_callback(message['url'], log, data_resp['env']))
    elif exists(MPV_SOCKET) and message['single']:
        spawn(get_unix_callback(message['url'], log, data_resp['env']))
    else:
         spawn_init(message['url'], log, data_resp['env'])

    data_resp.clear()
    LOG.debug('mpv should open soon')
    LOG.debug('Exiting with status 0')
    return 0


def main() -> int:
    if '--version' in sys.argv or '-V' in sys.argv:
        print(VERSION)
        return 0
    if '--help' in sys.argv or '-h' in sys.argv:
        print(('This script is intended to be used with the '
               'Chrome extension. There is no CLI interface for general use.'),
              file=sys.stderr)
        return 0
    makedirs(LOG_PATH)
    out_log_path = path_join(LOG_PATH, 'open-in-mpv.log')
    with open(out_log_path, 'a+') as log:
        return real_main(log)


if __name__ == '__main__':
    sys.exit(main())
